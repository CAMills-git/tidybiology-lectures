---
title: "02_dplyr_student"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Loading the `uniprot_region` dataset into RStudio 

The uniprot dataset can be found in the Tidybio package

To install and load the package, run the following

```{r install Tidybio, echo = TRUE, warning = FALSE, message = FALSE, eval = TRUE}
devtools::install_github("BAREJAA/Tidybio_pkg", build_vignettes = TRUE, force = TRUE)

library(Tidybio)
```

To load the `uniprot_region` dataset, run the following

```{r load uniprot_region, echo = TRUE, warning = FALSE}
data(uniprot_region)
```

## Converting the `uniprot_region` dataset to a tbl 

Convert `uniprot_region` to a tbl and assign it to a new object called `uniprot`

```{r uniprot_region tbl, echo = TRUE, warning = FALSE}
uniprot <- tbl_df(uniprot_region)
```

## Inspecting the `uniprot` dataset 

Use the `dim()` function to see how many rows (observations) and columns (variables) there are

```{r dim, echo = TRUE, warning = FALSE}
dim(uniprot)
```

## Inspecting the `uniprot` dataset 

Use the `glimpse()` function to see what kinds of variables the dataset contains
```{r glimpse, echo = TRUE, warning = FALSE}
glimpse(uniprot)
```

## Basic Data Types in R {.build}

R has 6 basic data ypes -

**character** - `"a"`, `"tidyverse"`  

**numeric** - `2`, `11.5`  

**integer** - `2L` (the `L` tells R to store this as an integer)  

**logical** - `TRUE`, `FALSE`  

**complex** - `1+4i`  

(**raw**)

You will also come across the **double** datatype. It is the same as **numeric**

**factor**. A **factor** is a collection of *ordered* character variables

## Basic Data Types in R 

In addition to the `glimpse()` function, you can use the `class()` function to determine the data type of a specific column

```{r class, echo = TRUE, warning = FALSE}
class(uniprot$Gene.Length)
```

## (Re)Introducing `%>%` 

The `%>%` operator is a way of "chaining" together strings of commands that make reading your code easy. The following code chunk illustrates how `%>%` works

```{r %>%, eval = TRUE, echo = TRUE}
uniprot %>% 
  select(Entry, Protein.Length) %>% 
  filter(Protein.Length > 500) 
```

The above code chunk does the following - it takes you dataset, `uniprot`, and "pipes" it into `select()`

## (Re)Introducing `%>%` 

The second line selects just the columns named "Entry" and Protein.Length" and "pipes" that into `filter()`. The final line selects proteins that are longer than 500 amino acids

When you see `%>%`, think "and then"

The alternative to using `%>%` is running the following code 

```{r alternative, eval = TRUE, echo = TRUE}
filter(select(uniprot, Entry, Protein.Length), Protein.Length > 500)
```

Although this is only one line as opposed to three, it's both more difficult to write and more difficult to read

## Introducing the main dplyr verbs 

dplyr is a package that contains a suite of functions that allow you to easily manipulate a dataset      

Some of the things you can do are -

- select rows and columns that match specific criteria

- create new variables (columns)

- obtain summary statistics on individual groups within your datsets 

The main verbs we will cover are `select()`, `filter()`, `arrange()`, `mutate()`, and `summarise()`. These all combine naturally with `group_by()` which allows you to perform any operation "by group"

## `select()` 

The `select()` verb allows you to extract specific columns from your dataset  

The most basic `select()` is one where you comma separate a list of columns you want included

For example, if you only want to select the "Gene.Name" and "Protein.Length" columns, run the following code chunk 

```{r select simple, eval = TRUE, echo = TRUE}
uniprot %>% 
  select(Gene.Name, Protein.Length) 
```

## `select()` 

If you want to select all columns *except* "Gene.Name", run the following 

```{r select exclude, eval = TRUE, echo = TRUE}
uniprot %>% 
  select(-Gene.Name) 
```

## `select()` 

Finally, you can provide a range of columns to return two columns and everything in between. For example 

```{r select range, eval = TRUE, echo = TRUE}
uniprot %>% 
  select(Entry:Protein.Length) 
```

This code selects the following columns - "Entry", "Protein.Name", "Gene.Name", and "Protein.Length"

## `select()` exercise 

Select the following columns - "Protein.Length", "Gene.Start", "Gene.End", and "Gene.Length"

```{r select solution, eval = TRUE, echo = TRUE}

```

## `filter()` 

The `filter()` verb allows you to choose rows based on certain condition(s) and discard everything else

All filters are performed on some logical statement

If a row meets the condition of this statement (i.e. is true) then it gets chosen (or "filtered"). All other rows are discared

## `filter()` 

Filtering can be performed on categorical data

```{r filter categorical, eval = TRUE, echo = TRUE}
uniprot %>% 
  filter(Cell.Region == "Membrane") 
```

The code chunk above only selects membrane-associated proteins

Note that `filter()` only applies to rows, and has no effect on columns

## `filter()` 

Filtering can also be performed on numerical data

For example, to select proteins longer than 500 amino acids, run the following code

```{r filter numerical, eval = TRUE, echo = TRUE}
uniprot %>% 
  filter(Protein.Length > 500) 
```

## `filter()` 

To filter on multiple conditions, you can write a sequence of `filter()` commands

For example, to select membrane-associated proteins *and* proteins that are longer than 500 amino acids, run the following 

```{r filter both, eval = TRUE, echo = TRUE}
uniprot %>% 
  filter(Cell.Region== "Membrane") %>% 
  filter(Protein.Length > 500) 
```

## `filter()` 

To avoid writing multiple `filter()` commands, multiple logical statements can be put inside a single `filter()` command, separated by commas

```{r filter both efficient, eval = TRUE, echo = TRUE}
uniprot %>% 
  filter(Cell.Region== "Membrane",
         Protein.Length > 500) 
```

## `filter()` exercise 

Filter all proteins NOT associated with a membrane, and that are at most 300 amino acids in length

`!=` = "not equal to"

`<=` = "less than or equal to"

```{r filter exercise, eval = TRUE, echo = TRUE}

```

## `arrange()` 

You can use the `arrange()` verb to sort rows

The input for arrange is one or many columns, and `arrange()` sorts the rows in ascending order i.e. from smallest to largest

For example, to sort rows from smallest to largest protein, run the following 

```{r arrange, eval = TRUE, echo = TRUE}
uniprot %>% 
  arrange(Protein.Length) 
```

## `arrange()` 

To reverse this order, use the `desc()` function within `arrange()`

```{r arrange desc, eval = TRUE, echo = TRUE}
uniprot %>% 
  arrange(desc(Protein.Length)) 
```

## `arrange()` exercise 

What happens when you apply `arrange()` to a categorical variable?

```{r arrange exercise, eval = TRUE, echo = TRUE}

```

## `mutate()` 

The `mutate()` verb, unlike the ones covered so far, creates new variable(s) i.e. new column(s). For example

```{r mutate simple, eval = TRUE, echo = TRUE}
uniprot %>% 
  mutate(sqrt_length = sqrt(Protein.Length)) 
```

The code chunk above takes all the elements of the column "Protein.Length", evaluates the square root of each element, and populates a new column called "sqrt_length" with these results

## `mutate()` 

Multiple columns can be used as inputs. For example 

```{r mutate multiple, eval = TRUE, echo = TRUE}
uniprot %>% 
  mutate(protein_gene_length = Protein.Length/Gene.Length) 
```

This code takes the protein length of each protein and divides it by the corresponding gene length

The results are stored in a new column called "protein_gene_length"

## `mutate()` exercise 

Create a new column (give it any name you like) and fill it with gene lengths divided by 1000

```{r mutate exercise, eval = TRUE, echo = TRUE}

```

## `summarise()` 

`summarise()` produces a new dataframe that aggregates that values of a column based on a certain condition.

For example, to calculate the mean protein and gene length, run the following 

```{r summarise, eval = TRUE, echo = TRUE}
uniprot %>% 
  summarise(mean(Protein.Length), mean(Gene.Length))
```

## `summarise()` 

You can assign you own names by running the following 

```{r summarise name, eval = TRUE, echo = TRUE}
uniprot %>% 
  summarise(protein_mean = mean(Protein.Length), 
            gene_mean = mean(Gene.Length))
```

## `summarise()` exercise 

Make a new table that contains the mean, median and standard deviations of protein lengths

Use the `median()` and `sd()` functions to calculate median and standard deviation

```{r summarise exercise, eval = TRUE, echo = TRUE}

```

## `group_by()` {

`group_by()` and `summarise()` can be used in combination to summarise by groups

For example, if you'd like to know the mean length of proteins in each region, run the following 

```{r group_by and summarise, eval = TRUE, echo = TRUE}
uniprot %>% 
  group_by(Cell.Region) %>% 
  summarise(mean(Protein.Length)) 
```

## Putting it all togther 

```{r all together now, eval = TRUE, echo = TRUE}
uniprot %>% 
  select(Cell.Region, Gene.Length) %>% 
  filter(Gene.Length < 5000) %>% 
  mutate(gene_short = Gene.Length/100) %>% 
  group_by(Cell.Region) %>% 
  summarise(mean_gene_length = mean(gene_short)) %>% 
  arrange(desc(mean_gene_length))
```

## Saving a new dataset 

If you'd like to save the output of your wrangling, you will need to use the `<-` or `->` operators
```{r all together now save, eval = TRUE, echo = TRUE}
uniprot_new <-  uniprot %>% 
                  select(Cell.Region, Gene.Length) %>% 
                  filter(Gene.Length < 5000) %>% 
                  mutate(gene_short = Gene.Length/100) %>% 
                  group_by(Cell.Region) %>% 
                  summarise(mean_gene_length = mean(gene_short)) %>% 
                  arrange(desc(mean_gene_length)) 
```

To save `uniprot_new` as a new file (e.g. csv)

```{r csv save, eval = TRUE, echo = TRUE}
write_csv(uniprot_new, "uniprot_new.csv")
```

## For more help 

Run the following to access the Dplyr vignette for this course

```{r Dplyr vignette, eval = FALSE, echo = TRUE}
browseVignettes("Tidybio")
```





