---
title: "Day 2 lesson plan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(EBImage)
```

## Loading a dataset into R Studio
After downloading the dataset from the Uniprot site, save it in the same folder as the R markdown file. Call the file "uniprot.csv"

To load your dataset into R Studio, run the following code
```{r load data, eval = FALSE}
uniprot_data <- read.csv("~/MyFolder/uniprot.csv")
```

## Inspecting `uniprot_data`
Use the `dim()` function to see how many rows (observations) and columns (variables) there are
```{r dim, eval = FALSE}
dim(uniprot_data)
```
Use the `head()` function to look at the top 6 rows
```{r head, eval = FALSE}
head(uniprot_data)
```
Use the `glimpse()` function to see what kinds of variables the dataset contains
```{r glimpse, eval = FALSE}
glimpse(uniprot_data)
```

## Introducing `%>%`

The `%>%` operator is a way of "chaining" together strings of commands that make reading your code easy. The following code chunk illustrates how `%>%` works

```{r %>%, eval = FALSE, echo = TRUE}
uniprot_data %>% 
  select(Protein.Length) %>% 
  filter(Protein.Length > 500)
```

The above code chunk does the following - it takes you dataset, `uniprot_data`, and "pipes" it into `select()`. The second line selects just the column named "Protein.Length" and "pipes" that into `filter()`. The final line selects proteins that are longer than 500 amino acids. The alternative to using `%>%` is running the following code 

```{r alternative, eval = FALSE, echo = TRUE}
filter(select(uniprot_data, Protein.Length), Protein.Length > 500)
```

Although this is only one line as opposed to three, it's both more difficult to write and more difficult to read

## Introducing the main dplyr verbs

dplyr is a package that contains a suite of functions that allow you to easily manipulate a dataset. Some of the things you can do are select rows and columns that match specific criteria, create new variables (columns), and obtain summary statistics on individual groups within your datsets (for example, mean protein size per cell region)

The main verbs we will cover are `select()`, `filter()`, `mutate()`, `summarise()`, and `arrange()`. These all combine naturally with `group_by()` which allows you to perform any operation "by group"

## `select()`

The `select()` verb allows you to extract specific columns from your dataset. The most basic `select()` is one where you comma separate a list of columns you want included. For example, if you only want to select the "Protein.Names" and "Protein.Lengths" columns, run the following code chunk 

```{r select simple, eval = FALSE}
uniprot_data %>% 
  select(Protein.Names, Protein.Length)
```

If you want to select all columns *except* "Protein.Names", run the following 

```{r select exclude, eval = FALSE}
uniprot_data %>% 
  select(-Protein.Names)
```

Finally, you can provide a range of columns to return two columns and everything in between. For example 

```{r select range, eval = FALSE}
uniprot_data %>% 
  select(Entry:Protein.Length)
```

This code selects the following columns - Entry, Status, Protein.Names, Gene.Name, and Protein.Length

## `filter()`

The `filter()` verb allows you to choose rows based on certain condition(s) and discard everything else. All filters are performed on some logical statement. If a row meets the condition of this statement (i.e. is true) then it gets chosen (or "filtered"). All other rows are discared. Filtering can be performed on categorical data, for example 

```{r filter categorical, eval = FALSE}
uniprot_data %>% 
  filter(region == "Membrane")
```

The code chunk above only selects membrane-associated proteins. Note that `filter()` only applies to rows. It has no effect on columns

Filtering can also be performed on numerical data. For example, to select proteins longer than 500 amino acids, run the following code

```{r filter numerical, eval = FALSE}
uniprot_data %>% 
  filter(Protein.Length > 500)
```

To avoid writing multiple `filter()` commands, multiple logical statements can be put inside a single `filter()` command, separated by commas. For example, to select membrane-associated proteins *and* proteins that are longer than 500 amino acids, run the following 

```{r filter both, eval = FALSE}
uniprot_data %>% 
  filter(region == "Membrane",
         Protein.Length > 500)
```

## `arrange()`

You can use the `arrange()` verb to sort rows. The input for arrange is one or many columns, and `arrange()` sorts the rows in ascending order i.e. from smallest to largest. For example, to sort rows from smallest to largest protein, run the following 

```{r arrange, eval = FALSE}
uniprot_data %>% 
  arrange(Protein.Length)
```

To reverse this order, use the `desc()` function within `arrange()`

```{r arrange desc, eval = FALSE}
uniprot_data %>% 
  arrange(desc(Protein.Length))
```

## `mutate()`

```{r mutate image, warning = FALSE, echo = FALSE, fig.cap="Artwork by @allison_horst"}
img1 <- readImage("~/Desktop/R Stuff/Bio 710/Lesson plans/dplyr_mutate.png")
display(img1)
```

The `mutate()` verb, unlike the ones covered so far, creates new variable(s) i.e. new column(s)

As a simple example, run the following 

```{r mutate simple, eval = FALSE}
uniprot_data %>% 
  mutate(sqrt_length = sqrt(Protein.Length))
```

The code chunk above takes all the elements of the column "Protein.Length", evaluates the square root of each element, and populates a new column called "sqrt_length" with these results

Multiple columns can be used as inputs. For example 

```{r mutate multiple, eval = FALSE}
uniprot_data %>% 
  mutate(protein_gene_length = Protein.Length/Gene.Length)
```

This code takes the protein length of each protein and divides it by the corresponding gene length. The results are stored in a new column called "protein_gene_length"

## `summarise()`

`summarise()` produces a new dataframe that aggregates that values of a column based on a certain condition. For example, to calculate the mean protein and gene length, run the following code 

```{r summarise, eval = FALSE}
uniprot_data %>% 
  summarise(mean(Protein.Length), mean(Gene.Length))
```

You can assign you own names by running the following code

```{r summarise name, eval = FALSE}
uniprot_data %>% 
  summarise(protein_mean = mean(Protein.Length), 
            gene_mean = mean(Gene.Length))
```

## `group_by()`

`group_by()` and `summarise()` go hand-in-hand. They can be used in combination to summarise by groups. For example, instead of calculating the mean length of all proteins, if you'd like to know the mean length of proteins in each region, run the following 

```{r group_by and summarise, eval = FALSE}
uniprot_data %>% 
  group_by(region) %>% 
  summarise(mean(Protein.Length))
```











